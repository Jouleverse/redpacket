# redpacket
on-chain red packet implementation
链上红包的实现方案

## 基本思路

* 把wJ放到红包合约中锁定供领取。
* 一个合约，多批红包。每批红包有自己的hash。前端支持的时候使用类似于 /redpacket/合约地址/红包hash 的方式来定位到具体某一批红包。用hash而不是数字id是为了防止简单猜测就能找到其他批次的红包（由于链上数据透明，这是防君子不防小人）。
* 一次交易上链完成wJ的存入和红包的创建。创建人需要先授权红包合约扣除其地址中的wJ。创建人设定红包总量（XX wJ，限制为0.01（含） - 500 wJ（含）之间）以及这一批的红包个数（YY 个 —— 为简化，限制为 1（含） 到 500（含） 之间）。每个红包含多少wJ是创建时就预计算好的（链下完成，不是由链上智能合约计算的），而且每个红包的大小（wJ的含量）是随机划分的（当然，链上数据是透明的，想看的人是能有办法读取出来这些数据的）。
* 抢红包必须先完成JTI认证并获得初始gas空投（否则无法进行链上交互）。
* 限制每个JTI认证的地址对每一批红包只能抢一个，不能重复多次抢。

## 算法

### 创建红包

链下预计算（比如js）。已知两个参数：1. 红包总量 XX wJ；2. 红包个数 YY

设 max = XX * 10^18，循环YY次，每次在 (0, max/2] 范围内随机取一个整数 p，作为一个红包；令 max = max - p，继续循环，直到所有红包都计算出来。

把YY个红包的能量值作为参数，发送给红包合约，合约验证总数和要扣除的wJ数字匹配，从创建地址中扣除wJ（需提前授权），创建红包数据。

数据结构：
```
mapping(红包hash => struct {
  total: 红包总能量值,
  amount: list[红包能量值], //原始数据，每一个红包包含的能量值
  quantity: 红包总数,
  left: 剩余未抢红包数量, //当减少到0的时候就不能抢了，向合约抢红包会返回error
  index: mapping(idx => 红包id), //剩余未抢红包的id 0 ~ {quantity - 1}
  winner: mapping(address => 红包id), //已经抢到红包的地址及其抢到的红包id
})
```

函数原型：
```
create(total, quantity, [amount])
```

TODO: 红包hash还需要一个算法（最好是链上？）

### 抢红包

首先，该地址需要有JTI。（禁止女巫）

其次，如果该地址已经抢过红包（在winner列表里），就不能再抢了。（禁止重放）

取若干不可预知的数据源，比如上一区块哈希值，加上抢红包者的地址，加上nonce等，算一个hash，然后对剩余未抢红包数量求余，算出一个“随机”的index值（这个算法要在合约里运行，不能是链下，防止用户操纵）。根据该index值，从上述数据结构中查找出对应的红包id；将该红包id从index中删除（代表已经被抢走了），减少剩余未抢红包数量，把该红包id对应的amount数量能量的wJ发送给抢红包者的地址。（注意先减数据，最后再发放wJ，防止重入攻击）

函数原型：
```
draw(红包hash）
```

## 版本历史

* 2023.9.8 spec-v1.0 evan.j 
